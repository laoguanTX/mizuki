---
title: "指针"
published: 2024-11-01
category: ["程设计科", "编程语言"]
tags: ["C/C++"]
alias: "pointer"
---

[card title="声明" color="info"]文章内容来自于《C++ Primer Plus》，本文重新组织语言，选取书本部分内容重新组合。[/card]

### 一、什么是指针

指针是一个变量，其存储的是值的地址，而不是值本身。在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（`&`），就可以获得它的位置，例如，如果`home`是一个变量，则`&home`是它的地址。

```cpp
#include<iostream>
using namespace std;
int main(){
    int home=1;
    double house=2.0;
    cout<<home<<endl<<&home<<endl<<house<<endl<<&house;
    return 0;
}
//输出:
//1
//0xdea99ff744
//2
//0xdea99ff748
```

显示地址时，`cout`使用十六进制表示法，因为这是常用于描述内存的表示法（有些实现可能使用十进制表法）。在上述代码中，`home`存储位置比`house`要低。两个地址的差为4。这是有意义的，因为`home`的类型为`int`，而这种类型使用4个字节。当然， 不同系统给定的地址值可能不同。有些系统可能先存储`house`，再存储`home`，这样两个地址值的差将为8个字节，因为`house`的类型为`double`。另外，在有些系统中，可能不会将这两个变量存储在相邻的内存单元中。

另一种特殊类型的变量是指针，用于存储值的地址。指针名表示的是地址。`*`运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同；C++根据上下文来确定所指 的是乘法还是解除引用）。例如，假设`manly`是一个指针，则`manly`表示的是一个地址，而`*manly`表示存储在该 地址处的值。`*manly`与常规`int`变量等效。

```cpp
#include<iostream>
using namespace std;
int main(){
    int manly=1;
    int *home=&manly;
    cout<<manly<<endl<<&manly<<endl;
    cout<<*home<<endl<<home<<endl;
    cout<<*&manly;
    return 0;
}
//输出:
//1
//0xbedcdff93c
//1
//0xbedcdff93c
//1
```

从中可知，`int`变量`manly`和指针变量`home`只不过是同一枚硬币的两面。变量`manly`表示值， 并使用`&`运算符来获得地址；而变量`home`表示地址，并使用`*`运算符来获得值。由于`home`指向`manly`，因此`*home`和`manly`完全等价。可以像使用`int`变量那样使用`*home`。甚至可以将值赋给`*home`。这样做将修改指向的值，即`manly`。

```cpp
#include<iostream>
using namespace std;
int main(){
    int manly=1;
    int *home=&manly;
    *home=2;
    cout<<manly;
    return 0;
}
//输出:
//2
```

### 二、声明和初始化指针

计算机需要跟踪指针指向的值的类型。例如，`char`的地址与`double`的地址看上去没什么两样，但`char`和`double`使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此， 指针声明必须指定指针指向的数据的类型。例如，前一个示例包含这样的声明：

`int *home;`

这表明，`*home`的类型为`nt`。由于`*`运算符被用于指针，因此`home`变量本身必须是指针。我 们说`home`指向`int`类型，我们还说`home`的类型是指向`int`的指针，或`int*`。可以这样说，`home`是指针（地址），而`*home`是 `int`，而不是指针。顺便说一句，`*`运算符两边的空格是可选的。`int  *ptr`、`int* ptr`，在哪里添加空格对于编译器来说没有任何区别，甚至可以这样做：`int*ptr`，但要知道的是，下面的声明创建一个指针（`p1`）和一个 `int`变量（`p2`）：`int* pl,p2`，对每个指针变量名，都需要使用一个`*`。

可以用同样的句法来声明指向其他类型的指针：

```cpp
double * tax;
char * str;
```

由于已将`tax`声明为一个指向`double`的指针，因此编译器知道`*tax`是一个`double`类型的值。也就是说，它知道`*tax`是一个以浮点格式存储的值，这个值（在大多数系统上）占据8个字节。指针变量不仅仅是指针，而且是指向特定类型的指针。`tax`的类型是指向`double`的指针（或`double *`类型），`str`是指向`char`的指针类型（或 `char *`）。尽管它们都是指针，却是不同类型的指针。和数组一样，指针都是基于其他类型的。

虽然`tax_ptr`和`str`指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的。也就是说，`char`的地址与`double`的地址的长度相同，这就好比1016可能是超市的街道地址，而1024可以是小村庄的街道地址一样。地址的长度或值既不能指示关于变量的长度或类型的任何信息，也不能指示该地址上有什么建筑物。一般来说，地址需要2个还是4个字节，取决于计算机系统（有些系统可能需要更大的地址，系统可以针对不同的类型使用不同长度的地址）。

可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。也就是说， 下面的语句将`pt`（而不是`*pt`）的值设置为`&higgens`

```cpp
int higgens=5;
int *pt=&higgens;
```

### 三、指针的危险

危险更易发生在那些使用指针不仔细的人身上。极其重要的一点是：在 C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦，如下所示：

```cpp
int *a;
*a=54188;
```

`a`确实是一个指针，但它指向哪里呢？上述代码没有将地址赋给`a`。那么54188将被放在哪里呢？我们不知道。由于`a`没有被初始化，它可能有任何值。不管值是什么， 程序都将它解释为存储54188的地址。如果`a`的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。`a`指向的地方很可能并不是所要存储54188的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。

### 四、指针和数字

指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看， 指针与整数是截然不同的类型。 整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针：

```cpp
//下面是错误代码
int *p;
p=0xB8000000
```

在这里，左边是指向`int`的指针，因此可以把它赋给地址，但右边是一个整数。您可能知道，`0xB8000000`是老式计算机系统中视频内存的组合段偏移地址，但这条语句并没有告诉程序，这个数字就是一个地址。 在C99标准发布之前，C语言允许这样赋值。但C++在类型一致方面的要求更严格，编译器将显示一条 错误消息，通告类型不匹配。要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：

这样，赋值语句的两边都是整数的地址，因此这样赋值有效。注意，`p`是`int`值的地址并不意味着`p`本身的类型是 `int`。例如，在有些平台中，`int`类型是个2字节值，而地址是个4字节值。